/**
   * qwik-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
import * as Qwik from '@builder.io/qwik';
import { createTable } from '@tanstack/table-core';
export * from '@tanstack/table-core';

const isFunction = comp => typeof comp === 'function';
const isQwikComponent = comp => isFunction(comp) && comp.name === 'QwikComponent';
function flexRender(Comp,
// TODO: add renderable type
props) {
  return !Comp ? null : isQwikComponent(Comp) ? /*#__PURE__*/React.createElement(Comp, props) : isFunction(Comp) ? Comp(props) : Comp;
}
function useQwikTable(options) {
  // Compose in the generic options to the user options
  const resolvedOptions = {
    state: {},
    onStateChange: () => {},
    renderFallbackValue: null,
    ...options
  };

  // Create a new table instance and store it in a Qwik store
  const table = Qwik.useStore({
    instance: Qwik.noSerialize(createTable(resolvedOptions))
  });

  // By default, manage table state here using the table's initial state
  const state = Qwik.useSignal(table.instance.initialState);

  // Compose the default state above with any user state. This will allow the user
  // to only control a subset of the state if desired.
  table.instance.setOptions(prev => ({
    ...prev,
    ...options,
    state: {
      ...state.value,
      ...options.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: updater => {
      state.value = updater instanceof Function ? updater(state.value) : updater;
      options.onStateChange == null || options.onStateChange(updater);
    }
  }));
  return table.instance;
}

export { flexRender, useQwikTable };
//# sourceMappingURL=index.esm.js.map
